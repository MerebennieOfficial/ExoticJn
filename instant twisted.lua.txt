local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local ANIM_NUM = "13294471966"
local ANIM_ID_PREFIX = "rbxassetid://" .. ANIM_NUM
local POST_DETECT_DELAY = 0.33
local FIRST_ROT_DEG = 210
local SECOND_ROT_DEG = 170
local BETWEEN_ROT_DELAY = 0.1

local MOVE_DISTANCE = 2
local MOVE_DURATION = 0.08
local EXTRA_ROT_DELAY = 0.3 -- changed from 0.44 to 0.3
local EXTRA_ROT_DEGREES = 20
local EXTRA_ROT_DISABLE_TIME = 0.4
-- cooldown & proximity
local COOLDOWN_TIME = 4
local PROXIMITY_RANGE = 8

-- helpers to query character/humanoid/root
local function getCharacter() return LocalPlayer and LocalPlayer.Character end
local function getHumanoid() local c = getCharacter() return c and c:FindFirstChildOfClass("Humanoid") end
local function getRoot()
    local c = getCharacter()
    return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso"))
end

-- existing helpers you provided (kept intact)
local function getNil(name,class)
    if type(getnilinstances)=="function" then
        for _,v in pairs(getnilinstances()) do
            if v.ClassName==class and v.Name==name then return v end
        end
    end
    return nil
end

-- performRemotes kept as-is
local function performRemotes()
    pcall(function()
        local args1 = {[1]={["Dash"]=Enum.KeyCode.W,["Key"]=Enum.KeyCode.Q,["Goal"]="KeyPress"}}
        local char = getCharacter()
        if char and char:FindFirstChild("Communicate") then
            char.Communicate:FireServer(unpack(args1))
        end
    end)
    pcall(function()
        local bv = getNil("moveme","BodyVelocity")
        local args2 = {[1]={["Goal"]="delete bv",["BV"]=bv}}
        local char = getCharacter()
        if char and char:FindFirstChild("Communicate") then
            char.Communicate:FireServer(unpack(args2))
        end
    end)
end

-- auto-rotate safing (kept)
local function disableAutoRotateSafely(h)
    if not h then return function() end end
    local orig = h.AutoRotate
    h.AutoRotate = false
    local conn
    conn = h:GetPropertyChangedSignal("AutoRotate"):Connect(function()
        if h.AutoRotate == true then h.AutoRotate = false end
    end)
    return function()
        if conn then conn:Disconnect(); conn = nil end
        if h and h.Parent then h.AutoRotate = orig end
    end
end

local function rotateYawRelative(root,degrees)
    if not root then return end
    root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(degrees), 0)
end

local function restoreOrientationPreservePos(root,originalCFrame)
    if not root or not originalCFrame then return end
    local pos = root.Position
    local origLook = originalCFrame.LookVector
    if not origLook or origLook.Magnitude <= 0.001 then origLook = root.CFrame.LookVector end
    root.CFrame = CFrame.new(pos, pos + origLook)
end

local function pushForwardForce(root, humanoid, distance, duration)
    if not root then return end
    local look = root.CFrame.LookVector
    local horizontal = Vector3.new(look.X, 0, look.Z)
    if horizontal.Magnitude <= 0.001 then return end
    local dir = horizontal.Unit
    local speed = distance / math.max(duration, 0.01)

    local success, origAV = pcall(function() return root.AssemblyLinearVelocity end)
    if not success then origAV = Vector3.new(0,0,0) end

    pcall(function()
        root.AssemblyLinearVelocity = dir * speed
    end)

    pcall(function()
        if humanoid and humanoid.Move then
            humanoid:Move(dir, true)
        elseif humanoid and typeof(humanoid.Move) == "function" then
            humanoid:Move(dir)
        end
    end)

    pcall(function()
        local tries = 3
        local per = distance / tries
        for i = 1, tries do
            if not root or not root.Parent then break end
            pcall(function() root.CFrame = root.CFrame + dir * per end)
            task.wait(duration / (tries + 0.1))
        end
    end)

    task.delay(duration, function()
        if not root or not root.Parent then return end
        pcall(function()
            root.AssemblyLinearVelocity = origAV or Vector3.new(0,0,0)
        end)
    end)
end

-- proximity check (kept)
local function humanoidNearby(range)
    local root = getRoot()
    if not root then return false end
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Humanoid") and obj.Parent then
            local parent = obj.Parent
            local hrp = parent:FindFirstChild("HumanoidRootPart") or parent:FindFirstChild("UpperTorso") or parent:FindFirstChild("Torso")
            if hrp and hrp.Position and (hrp.Position - root.Position).Magnitude <= range then
                if parent ~= getCharacter() then
                    return true
                end
            end
        end
    end
    return false
end

-- core sequence (kept, but will be called safely)
local _cooldown = false
local function doSequence()
    local char = getCharacter()
    local humanoid = getHumanoid()
    local root = getRoot()
    if not char or not humanoid or not root then return end

    if _cooldown then return end
    if not humanoidNearby(PROXIMITY_RANGE) then return end

    _cooldown = true
    task.delay(COOLDOWN_TIME, function() _cooldown = false end)

    task.wait(POST_DETECT_DELAY)
    performRemotes()

    local restoreAuto = disableAutoRotateSafely(humanoid)
    local originalCf = root.CFrame

    rotateYawRelative(root, FIRST_ROT_DEG)
    task.wait(BETWEEN_ROT_DELAY)
    rotateYawRelative(root, SECOND_ROT_DEG)
    task.wait(BETWEEN_ROT_DELAY)

    restoreOrientationPreservePos(root, originalCf)

    pcall(function()
        pushForwardForce(root, humanoid, MOVE_DISTANCE, MOVE_DURATION)
    end)

    -- Extra rotation after forward push
    task.delay(EXTRA_ROT_DELAY, function()
        if not root or not root.Parent then return end
        local undoAuto = disableAutoRotateSafely(humanoid)
        rotateYawRelative(root, EXTRA_ROT_DEGREES)
        task.delay(EXTRA_ROT_DISABLE_TIME, function()
            undoAuto()
        end)
    end)

    restoreAuto()
end

-- UI creation (kept but made safe & single-instance friendly)
local function createUI()
    -- If GUI already exists in PlayerGui or CoreGui, return its handlers
    local existing = nil
    pcall(function()
        existing = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("InstantTwistedToggleGui")
    end)
    if existing then
        -- try to read existing toggle state if present
        local wrapper = {}
        wrapper.Gui = existing
        -- try to find label to figure out toggled state
        pcall(function()
            local frame = existing:FindFirstChild("ToggleFrame")
            local label = frame and frame:FindFirstChild("Label")
            wrapper.IsEnabled = function() return (label and label.Text == "On") end
            wrapper.SetEnabled = function(state) if label then label.Text = state and "On" or "Off" end end
        end)
        return wrapper
    end

    local gui = Instance.new("ScreenGui")
    gui.Name = "InstantTwistedToggleGui"
    gui.IgnoreGuiInset = true
    gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    -- prefer PlayerGui (more compatible with mobile executors); fallback to CoreGui only if PlayerGui not found
    local parentSuccess = false
    pcall(function()
        if LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui") then
            gui.Parent = LocalPlayer.PlayerGui
            parentSuccess = true
        end
    end)
    if not parentSuccess then
        pcall(function() gui.Parent = game:GetService("CoreGui") end)
    end
    if not gui.Parent then
        -- final fallback
        gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end

    local frame = Instance.new("Frame")
    frame.Name = "ToggleFrame"
    frame.Size = UDim2.new(0, 50, 0, 40)
    frame.Position = UDim2.new(0, 100, 0, 100)
    frame.BackgroundColor3 = Color3.fromRGB(213, 178, 231)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Parent = gui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame

    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, -6, 1, -6)
    label.Position = UDim2.new(0, 3, 0, 3)
    label.BackgroundTransparency = 1
    label.Text = "Instant Twisted"
    label.TextWrapped = true
    label.TextScaled = true
    label.RichText = false
    label.Font = Enum.Font.SourceSansSemibold
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextStrokeColor3 = Color3.fromRGB(20, 20, 20)
    label.TextStrokeTransparency = 0.1
    label.Parent = frame

    local button = Instance.new("TextButton")
    button.Name = "ClickCatcher"
    button.Size = UDim2.new(1, 0, 1, 0)
    button.Position = UDim2.new(0, 0, 0, 0)
    button.BackgroundTransparency = 1
    button.Text = ""
    button.AutoButtonColor = false
    button.Parent = frame

    local soundOn = Instance.new("Sound")
    soundOn.Parent = frame
    soundOn.SoundId = "rbxassetid://15675059323"
    soundOn.Volume = 2

    local soundOff = Instance.new("Sound")
    soundOff.Parent = frame
    soundOff.SoundId = "rbxassetid://6895079853"
    soundOff.Volume = 2

    local toggled = false
    local busy = false

    local function pulseAnimation()
        local enlarge = TweenService:Create(frame, TweenInfo.new(0.08, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, 54, 0, 44),
        })
        local settle = TweenService:Create(frame, TweenInfo.new(0.14, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, 50, 0, 40),
        })
        enlarge:Play()
        enlarge.Completed:Wait()
        settle:Play()
    end

    local function setStateInternal(state)
        toggled = state and true or false
        if toggled then
            label.Text = "On"
            pcall(function() soundOn:Play() end)
        else
            label.Text = "Off"
            pcall(function() soundOff:Play() end)
        end
    end

    local function SetEnabled(state) setStateInternal(state and true or false) end
    local function IsEnabled() return toggled and true or false end

    local didMoveDuringDrag = false
    button.Activated:Connect(function()
        if didMoveDuringDrag then didMoveDuringDrag = false return end
        if busy then return end
        busy = true
        pcall(pulseAnimation)
        -- toggle text to On/Off when clicked
        setStateInternal(not toggled)
        task.delay(0.12, function() busy = false end)
    end)

    local dragging = false
    local dragStart = Vector2.new()
    local startPos = frame.Position
    local function startDrag(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            didMoveDuringDrag = false
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end
    local function updateDrag(input)
        if not dragging then return end
        if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then return end
        local delta = input.Position - dragStart
        if not didMoveDuringDrag and (math.abs(delta.X) > 3 or math.abs(delta.Y) > 3) then didMoveDuringDrag = true end
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    button.InputBegan:Connect(startDrag)
    button.InputChanged:Connect(updateDrag)
    UserInputService.InputChanged:Connect(updateDrag)

    UserInputService.InputBegan:Connect(function(input, gpe)
        if gpe then return end
        if input.KeyCode == Enum.KeyCode.K then
            if busy then return end
            busy = true
            pcall(pulseAnimation)
            setStateInternal(not toggled)
            task.delay(0.12, function() busy = false end)
        end
    end)

    -- return the wrapper
    return {Gui = gui, IsEnabled = IsEnabled, SetEnabled = SetEnabled}
end

-- create (or reuse) UI
ui = createUI()

-- ensure we always run sequence only when UI allows it (wrapper over doSequence)
local oldDoSequence = doSequence
doSequence = function()
    -- if ui exists and is a wrapper with IsEnabled, check it
    if ui and ui.IsEnabled and not ui.IsEnabled() then return end
    oldDoSequence()
end

-- ===== robust animation watcher binding logic =====
local boundHumanoid = nil
local humanoidConn = nil
local playingTrackConns = {} -- to store conn for each playing track (if needed)
local trackDebounce = {} -- simple debounce per track instance

local function clearHumanoidBindings()
    if humanoidConn then
        pcall(function() humanoidConn:Disconnect() end)
        humanoidConn = nil
    end
    for _, c in ipairs(playingTrackConns) do
        pcall(function() c:Disconnect() end)
    end
    playingTrackConns = {}
    trackDebounce = {}
    boundHumanoid = nil
end

local function extractAnimNum(anim)
    if not anim then return nil end
    local id = nil
    if typeof(anim) == "Instance" then
        id = tostring(anim.AnimationId or anim)
    else
        id = tostring(anim)
    end
    local num = id:match("(%d+)")
    return num
end

local function handleTrack(track)
    if not track then return end
    -- small per-track debounce so if the same track emits multiple times quickly we don't spam
    if trackDebounce[track] then return end
    local anim = track.Animation
    local num = extractAnimNum(anim)
    if num == ANIM_NUM then
        trackDebounce[track] = true
        spawn(function()
            -- If there's an IsEnabled function on the UI, respect it
            if ui and ui.IsEnabled and not ui.IsEnabled() then
                trackDebounce[track] = nil
                return
            end
            pcall(doSequence)
            task.wait(0.5)
            trackDebounce[track] = nil
        end)
    end
end

local function bindHumanoid(humanoid)
    if not humanoid then return end
    -- if it's already bound to same humanoid, nothing to do
    if boundHumanoid == humanoid then return end
    clearHumanoidBindings()
    boundHumanoid = humanoid

    -- connect AnimationPlayed
    humanoidConn = humanoid.AnimationPlayed:Connect(function(track)
        pcall(handleTrack, track)
    end)

    -- handle currently playing tracks too
    pcall(function()
        for _, t in ipairs(humanoid:GetPlayingAnimationTracks()) do
            -- schedule small delay to avoid racing during spawn
            task.spawn(function()
                pcall(handleTrack, t)
            end)
        end
    end)
end

-- wait-for-humanoid helper with timeout loop (robust across different loading speeds)
local function waitForHumanoid(char, timeout)
    timeout = timeout or 2
    local start = tick()
    while tick() - start < timeout do
        if not char then return nil end
        local h = char:FindFirstChildOfClass("Humanoid")
        if h then return h end
        task.wait(0.04)
    end
    return char:FindFirstChildOfClass("Humanoid")
end

local function onCharacterAdded(char)
    if not char then return end
    -- ensure we clear previous bindings (safety)
    clearHumanoidBindings()

    -- small delay to let character parts load
    task.wait(0.06)
    local humanoid = waitForHumanoid(char, 3)
    if humanoid then
        bindHumanoid(humanoid)
    else
        -- try again once after a short wait
        task.wait(0.2)
        humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then bindHumanoid(humanoid) end
    end
end

-- attach character listeners safely
if LocalPlayer.Character then
    onCharacterAdded(LocalPlayer.Character)
end

-- remove bindings when character is removed
LocalPlayer.CharacterRemoving:Connect(function(char)
    clearHumanoidBindings()
end)

-- re-bind when new character spawns (single listener)
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.08)
    onCharacterAdded(char)
    -- If UI got removed from PlayerGui/CoreGui unexpectedly, recreate
    local ok, present = pcall(function() return ui and ui.Gui and ui.Gui.Parent end)
    if not ok or not present then
        ui = createUI()
    end
end)

print("InstantTwisted (improved) loaded. Movable UI created. Animation", ANIM_ID_PREFIX, "will trigger the sequence and will rebind after respawn.")

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local DISCORD_LINK = "https://discord.gg/5x4xbPvuSc"

-- GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Merebennie_WatermarkGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.IgnoreGuiInset = true
ScreenGui.DisplayOrder = 9999
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

-- Main Frame
local Frame = Instance.new("Frame")
Frame.Name = "WatermarkFrame"
Frame.Size = UDim2.new(0, 200, 0, 160)  -- narrower width, taller height
Frame.Position = UDim2.new(1, 220, 0.5, -80) -- start off-screen (right middle)
Frame.AnchorPoint = Vector2.new(1, 0)  -- anchor to the right
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BackgroundTransparency = 0.15
Frame.ZIndex = 9999
Frame.Parent = ScreenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 18)
corner.Parent = Frame

-- Title (Top Center)
local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -20, 0, 40)
Title.Position = UDim2.new(0.5, 0, 0, 8)
Title.AnchorPoint = Vector2.new(0.5, 0)
Title.BackgroundTransparency = 1
Title.Text = "Made by Merebennie"
Title.Font = Enum.Font.GothamBold
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.ZIndex = 10000
Title.Parent = Frame

-- Description (Middle)
local Desc = Instance.new("TextLabel")
Desc.Size = UDim2.new(0.9, 0, 0, 50)
Desc.Position = UDim2.new(0.5, 0, 0.5, 0)  -- 👈 moved a bit lower (was -20)
Desc.AnchorPoint = Vector2.new(0.5, 0.5)
Desc.BackgroundTransparency = 1
Desc.Text = "Join our Discord for more high quality scripts."
Desc.Font = Enum.Font.Gotham
Desc.TextColor3 = Color3.fromRGB(255, 255, 255)
Desc.TextScaled = true
Desc.TextWrapped = true
Desc.ZIndex = 10000
Desc.Parent = Frame

-- Copy Label (Bottom Middle)
local CopyLabel = Instance.new("TextButton")
CopyLabel.Size = UDim2.new(0.8, 0, 0, 34)
CopyLabel.Position = UDim2.new(0.5, 0, 1, -45)
CopyLabel.AnchorPoint = Vector2.new(0.5, 0)
CopyLabel.BackgroundTransparency = 1
CopyLabel.Text = "Click me to copy"
CopyLabel.Font = Enum.Font.GothamBold
CopyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CopyLabel.TextScaled = true
CopyLabel.ZIndex = 10000
CopyLabel.Parent = Frame

-- Click sound
local ClickSound = Instance.new("Sound")
ClickSound.SoundId = "rbxassetid://5852470908"
ClickSound.Volume = 1
ClickSound.Parent = Frame

-- Copy functionality
CopyLabel.MouseButton1Click:Connect(function()
	if setclipboard then
		setclipboard(DISCORD_LINK)
	end
	ClickSound:Play()
	CopyLabel.Text = "Successfully Copied!"
	task.delay(1.5, function()
		if CopyLabel then
			CopyLabel.Text = "Click me to copy"
		end
	end)
end)

-- Slide in (from right)
local tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local slideIn = TweenService:Create(Frame, tweenInfo, {Position = UDim2.new(1, -15, 0.5, -80)})
slideIn:Play()

-- Slide out after 4.2 seconds
task.delay(4.2, function()
	local slideOut = TweenService:Create(Frame, tweenInfo, {Position = UDim2.new(1, 220, 0.5, -80)})
	slideOut:Play()
	slideOut.Completed:Connect(function()
		ScreenGui:Destroy()
	end)
end)
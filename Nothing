-- Delta Aimlock — Merebennie Final Build (Delta Mobile Executor Fixed)
-- Designed for Delta Mobile Executor compatibility
-- UI creation and parenting logic improved for reliability

-- ======= SERVICES =======
local Players          = game:GetService("Players")
local RunService       = game:GetService("RunService")
local TweenService     = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local SoundService     = game:GetService("SoundService")
local Workspace        = game:GetService("Workspace")
local Lighting         = game:GetService("Lighting")
local Stats            = game:GetService("Stats")
local CoreGui          = game:GetService("CoreGui")

local Camera = Workspace.CurrentCamera

-- ======= SAFETY WAIT =======
local LocalPlayer = Players.LocalPlayer
while not LocalPlayer do task.wait(0.05); LocalPlayer = Players.LocalPlayer end
-- Wait until PlayerGui exists and CoreGui is available
local PlayerGui = LocalPlayer:FindFirstChild("PlayerGui")
while not PlayerGui do task.wait(0.05); PlayerGui = LocalPlayer:FindFirstChild("PlayerGui") end

-- ======= HELPERS =======
local function safeNew(className)
    local ok, inst = pcall(function() return Instance.new(className) end)
    if ok then return inst end
    return nil
end

local function safeParent(obj, parent)
    if obj and parent then
        pcall(function() obj.Parent = parent end)
    end
end

local function try(func, ...)
    local ok, res = pcall(func, ...)
    if ok then return res end
    return nil
end

local function newSound(id)
    local s = safeNew("Sound")
    if not s then return nil end
    s.SoundId = id or ""
    s.Volume = 1
    safeParent(s, SoundService)
    return s
end

-- ======= CONFIG =======
local CFG = {
    AIM_RADIUS = 500,
    LOCK_PART  = "Head",

    AIM_MODE   = "Smooth", -- "Smooth" | "Snap"
    SMOOTHING  = 0.35,

    USE_CAM_HEIGHT = true,
    CAM_HEIGHT     = 2,
    SCREEN_TILT    = -5,

    TARGET_PRIORITY = "Screen", -- Angle | Screen | Distance

    SHOW_FOV = true,
    FOV_PIXELS = 120,
    FOV_THICKNESS = 3,

    CLICK_SOUND_ID = "rbxassetid://6042053626",

    USE_PREDICTION = true,
    BULLET_SPEED   = 1400, -- internal (not exposed)

    REQUIRE_VISIBLE = true,
    VIS_STICKY_TIME = 0.12,

    SHOW_FPS_COUNTER = true,
    FPS_SMOOTH_FACTOR = 0.9,

    BOOSTER_DEFAULT = false,

    SPAWN_MARKER_SIZE = Vector3.new(4, 0.2, 4),
}

-- ======= STATE =======
local aiming = false
local targetPart = nil
local targetHRP = nil
local lastYaw, lastPitch = nil, nil
local lastSwitchTick = 0
local avgDelta = 1/60
local lastSeenVisibleAt = 0

local spawnPointCFrame = nil
local spawnMarker = nil

-- ======= SOUNDS =======
local clickSound = newSound(CFG.CLICK_SOUND_ID)

-- ======= GUI CREATION (parent to CoreGui for Delta, fallback to PlayerGui) =======
local function parentGuiSafe(gui)
    local success = pcall(function()
        gui.Parent = CoreGui
    end)
    if not success or not gui.Parent then
        local plrGui = LocalPlayer:FindFirstChild("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui", 2)
        if plrGui then
            gui.Parent = plrGui
        else
            warn("[DeltaAim] Could not parent GUI to CoreGui or PlayerGui.")
        end
    end
end

local gui = safeNew("ScreenGui")
if not gui then error("Failed to create ScreenGui") end
gui.Name = "Merebennie_DeltaAim_UI"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
parentGuiSafe(gui)

-- Ensure UI reparenting resilience
LocalPlayer.CharacterAdded:Connect(function()
    if not gui.Parent then
        parentGuiSafe(gui)
    end
end)

task.spawn(function()
    while task.wait(2) do
        if not gui.Parent then
            parentGuiSafe(gui)
        end
    end
end)

-- UI helpers
local function applyTextStyle(lbl, size, bold, color)
    if not lbl then return end
    lbl.BackgroundTransparency = 1
    lbl.Font = bold and Enum.Font.GothamBold or Enum.Font.Gotham
    lbl.TextSize = size or 14
    lbl.TextColor3 = color or Color3.new(1,1,1)
    lbl.TextStrokeColor3 = Color3.new(0,0,0)
    lbl.TextStrokeTransparency = 0.15
end

local function makeRound(obj, radius)
    local c = safeNew("UICorner")
    c.CornerRadius = UDim.new(0, radius or 8)
    safeParent(c, obj)
end

local function addStroke(obj, thickness, color)
    local s = safeNew("UIStroke")
    s.Thickness = thickness or 1
    s.Color = color or Color3.fromRGB(0,0,0)
    safeParent(s, obj)
end

local function addGradient(obj, color1, color2, rotation)
    local g = safeNew("UIGradient")
    g.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, color1), ColorSequenceKeypoint.new(1, color2)}
    if rotation then g.Rotation = rotation end
    safeParent(g, obj)
end

local function tween(instance, props, time, style, dir)
    local t = TweenService:Create(instance, TweenInfo.new(time or 0.18, style or Enum.EasingStyle.Quad, dir or Enum.EasingDirection.Out), props)
    t:Play()
    return t
end

-- ======= WATERMARK =======
local watermark = safeNew("TextLabel")
watermark.Name = "Watermark"
watermark.Size = UDim2.new(0, 220, 0, 20)
watermark.Position = UDim2.new(0, 8, 0, 8)
watermark.AnchorPoint = Vector2.new(0,0)
watermark.BackgroundTransparency = 1
watermark.Font = Enum.Font.Arcade
watermark.TextSize = 16
watermark.Text = "Made by Merebennie"
applyTextStyle(watermark, 16, true, Color3.new(1,1,1))
safeParent(watermark, gui)

-- ======= MAIN FRAME =======
local mainFrame = safeNew("Frame")
mainFrame.Size = UDim2.new(0, 360, 0, 140)
mainFrame.Position = UDim2.new(0.5, -180, 0.12, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0)
mainFrame.BackgroundTransparency = 0
safeParent(mainFrame, gui)
makeRound(mainFrame, 14)
addStroke(mainFrame, 1)
addGradient(mainFrame, Color3.fromRGB(18,24,35), Color3.fromRGB(28,48,78), 90)

local title = safeNew("TextLabel")
title.Size = UDim2.new(0.7, -20, 0, 32)
title.Position = UDim2.new(0, 12, 0, 8)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Text = "Aimlock Controller"
applyTextStyle(title, 18, true)
safeParent(title, mainFrame)

-- Settings gear
local settingsBtn = safeNew("TextButton")
settingsBtn.Size = UDim2.new(0, 36, 0, 36)
settingsBtn.Position = UDim2.new(1, -12, 0, 8)
settingsBtn.AnchorPoint = Vector2.new(1,0)
settingsBtn.Text = "⚙"
applyTextStyle(settingsBtn, 18, true)
settingsBtn.BackgroundTransparency = 0
safeParent(settingsBtn, mainFrame)
makeRound(settingsBtn, 12); addStroke(settingsBtn, 1); addGradient(settingsBtn, Color3.fromRGB(220,230,255), Color3.fromRGB(190,200,230), 180)

-- ======= MAIN INDICATOR (70x70) =======
local mainIndicator = safeNew("Frame")
mainIndicator.Name = "MainIndicator"
mainIndicator.Size = UDim2.new(0, 70, 0, 70)
mainIndicator.Position = UDim2.new(0.03, 0, 0.5, 0)
mainIndicator.AnchorPoint = Vector2.new(0, 0.5)
mainIndicator.BackgroundTransparency = 0
safeParent(mainIndicator, mainFrame)
makeRound(mainIndicator, 12); addStroke(mainIndicator, 1); addGradient(mainIndicator, Color3.fromRGB(255,255,255), Color3.fromRGB(235,240,255), 45)

local indicatorDot = safeNew("Frame")
indicatorDot.Size = UDim2.new(0, 18, 0, 18)
indicatorDot.Position = UDim2.new(0.5, -9, 0.5, -9)
indicatorDot.BackgroundColor3 = Color3.fromRGB(180,30,30)
makeRound(indicatorDot, 50)
safeParent(indicatorDot, mainIndicator)

-- ======= AIMBOT CIRCLE (Text-only) =======
local aimbotCircle = safeNew("TextButton")
aimbotCircle.Name = "AimbotCircle"
aimbotCircle.Size = UDim2.new(0, 70, 0, 70)
aimbotCircle.Position = UDim2.new(0.5, -35, 0.5, -35)
aimbotCircle.AnchorPoint = Vector2.new(0.5,0.5)
aimbotCircle.Text = "AIMBOT"
aimbotCircle.Font = Enum.Font.GothamBold
aimbotCircle.TextSize = 14
applyTextStyle(aimbotCircle, 14, true)
aimbotCircle.BackgroundTransparency = 0
safeParent(aimbotCircle, mainFrame)
makeRound(aimbotCircle, 35); addStroke(aimbotCircle, 1); addGradient(aimbotCircle, Color3.fromRGB(255,140,80), Color3.fromRGB(220,80,40), 0)

-- ======= FPS LABEL & BOOSTER TOGGLE =======
local fpsLabel = safeNew("TextLabel")
fpsLabel.Size = UDim2.new(0, 110, 0, 20)
fpsLabel.Position = UDim2.new(1, -12, 0, 10)
fpsLabel.AnchorPoint = Vector2.new(1,0)
fpsLabel.Text = "FPS: 0.0"
applyTextStyle(fpsLabel, 14, true)
safeParent(fpsLabel, mainFrame)

local boosterToggle = safeNew("TextButton")
boosterToggle.Size = UDim2.new(0, 78, 0, 26)
boosterToggle.Position = UDim2.new(1, -110, 0, 8)
boosterToggle.AnchorPoint = Vector2.new(1,0)
boosterToggle.Text = CFG.BOOSTER_DEFAULT and "BOOST ON" or "BOOST OFF"
applyTextStyle(boosterToggle, 12, true)
safeParent(boosterToggle, mainFrame)
makeRound(boosterToggle, 12); addStroke(boosterToggle, 1); addGradient(boosterToggle, Color3.fromRGB(255,200,120), Color3.fromRGB(200,160,80), 0)

-- ======= FOV RING =======
local fovFrame = safeNew("Frame")
fovFrame.Name = "FOVFrame"
fovFrame.AnchorPoint = Vector2.new(0.5,0.5)
fovFrame.Position = UDim2.new(0.5,0,0.5,0)
fovFrame.Size = UDim2.new(0, CFG.FOV_PIXELS*2, 0, CFG.FOV_PIXELS*2)
fovFrame.BackgroundTransparency = 1
fovFrame.Visible = CFG.SHOW_FOV
safeParent(fovFrame, gui)
local fovInner = safeNew("Frame"); fovInner.Size = UDim2.new(1,0,1,0); fovInner.BackgroundTransparency = 1; safeParent(fovInner, fovFrame)
local fovStroke = safeNew("UIStroke"); fovStroke.Thickness = CFG.FOV_THICKNESS; fovStroke.Color = Color3.fromRGB(255,255,255); fovStroke.Transparency = 0.6; safeParent(fovStroke, fovInner)

-- ======= SETTINGS PANEL (Clean & Compact) =======
local settingsFrame = safeNew("Frame")
settingsFrame.Name = "SettingsPanel"
settingsFrame.Size = UDim2.new(0, 300, 0, 180)
settingsFrame.Position = UDim2.new(0.5, -150, 0.25, 0)
settingsFrame.AnchorPoint = Vector2.new(0.5,0)
settingsFrame.BackgroundTransparency = 0
settingsFrame.Visible = false
safeParent(settingsFrame, gui)
makeRound(settingsFrame, 12); addStroke(settingsFrame, 1); addGradient(settingsFrame, Color3.fromRGB(235,245,255), Color3.fromRGB(210,225,240), 90)

local sTitle = safeNew("TextLabel"); sTitle.Size = UDim2.new(1, -16, 0, 30); sTitle.Position = UDim2.new(0, 8, 0, 6); sTitle.Text = "Settings"; applyTextStyle(sTitle, 16, true); safeParent(sTitle, settingsFrame)

-- neat rows inside settings
local function mkRow(y)
    local row = safeNew("Frame"); row.Size = UDim2.new(1, -16, 0, 34); row.Position = UDim2.new(0, 8, 0, y); row.BackgroundTransparency = 1; safeParent(row, settingsFrame); return row end

-- prediction toggle pill
local function makePillToggle(parent, label, default, onChange, posY)
    local row = mkRow(posY)
    local pill = safeNew("Frame"); pill.Size = UDim2.new(0.62, 0, 1, 0); pill.Position = UDim2.new(0, 0, 0, 0); pill.BackgroundTransparency = 0; pill.BackgroundColor3 = Color3.fromRGB(40,40,50); makeRound(pill, 14); addStroke(pill,1); safeParent(pill, row)
    local txt = safeNew("TextLabel"); txt.Size = UDim2.new(0.65, 0, 1, 0); txt.Position = UDim2.new(0, 8, 0, 0); txt.Text = label; applyTextStyle(txt, 14, false); txt.TextXAlignment = Enum.TextXAlignment.Left; safeParent(txt, pill)
    local toggle = safeNew("TextButton"); toggle.Size = UDim2.new(0.33, -8, 0, 22); toggle.Position = UDim2.new(0.67, 0, 0.1, 0); toggle.Text = default and "ON" or "OFF"; applyTextStyle(toggle, 12, true); safeParent(toggle, pill); makeRound(toggle,10); addStroke(toggle,1); addGradient(toggle, Color3.fromRGB(120,220,120), Color3.fromRGB(40,180,80), 0)
    toggle.MouseButton1Click:Connect(function()
        if clickSound then clickSound:Play() end
        local v = toggle.Text == "ON"; v = not v; toggle.Text = v and "ON" or "OFF"; if onChange then pcall(onChange, v) end
    end)
    return row
end

-- smoothing slider row (compact)
local function makeSlider(parent, label, default, posY)
    local row = mkRow(posY)
    local txt = safeNew("TextLabel"); txt.Size = UDim2.new(0.62,0,1,0); txt.Position = UDim2.new(0,0,0,0); txt.Text = label .. ": " .. string.format("%.2f", default); applyTextStyle(txt, 14, false); safeParent(txt, row)
    local minus = safeNew("TextButton"); minus.Size = UDim2.new(0,26,0,24); minus.Position = UDim2.new(0.62, 8, 0, 5); minus.Text = "-"; applyTextStyle(minus, 16, true); safeParent(minus, row); makeRound(minus,6); addStroke(minus,1)
    local plus = safeNew("TextButton"); plus.Size = UDim2.new(0,26,0,24); plus.Position = UDim2.new(0.86,8,0,5); plus.Text = "+"; applyTextStyle(plus, 16, true); safeParent(plus, row); makeRound(plus,6); addStroke(plus,1)
    local value = default
    local function update(v) value = math.clamp(v, 0, 1); txt.Text = label .. ": " .. string.format("%.2f", value); CFG.SMOOTHING = value end
    minus.MouseButton1Click:Connect(function() if settingsFrame.Visible then update(value - 0.05); if clickSound then clickSound:Play() end end)
    plus.MouseButton1Click:Connect(function() if settingsFrame.Visible then update(value + 0.05); if clickSound then clickSound:Play() end end)
    update(default)
    return row
end

-- Minimal settings content
makePillToggle(settingsFrame, "Prediction (On/Off)", CFG.USE_PREDICTION, function(v) CFG.USE_PREDICTION = v end, 40)
makeSlider(settingsFrame, "Aim Smoothing", CFG.SMOOTHING, 84)
-- FOV simple +/- controls
do
    local row = mkRow(128)
    local label = safeNew("TextLabel"); label.Size = UDim2.new(0.6,0,1,0); label.Position = UDim2.new(0,0,0,0); label.Text = "FOV Size: " .. tostring(CFG.FOV_PIXELS); applyTextStyle(label, 14, false); safeParent(label, row)
    local less = safeNew("TextButton"); less.Size = UDim2.new(0,26,0,24); less.Position = UDim2.new(0.62,8,0,5); less.Text = "-"; applyTextStyle(less,16,true); safeParent(less, row); makeRound(less,6); addStroke(less,1)
    local more = safeNew("TextButton"); more.Size = UDim2.new(0,26,0,24); more.Position = UDim2.new(0.86,8,0,5); more.Text = "+"; applyTextStyle(more,16,true); safeParent(more, row); makeRound(more,6); addStroke(more,1)
    less.MouseButton1Click:Connect(function() if not settingsFrame.Visible then return end; CFG.FOV_PIXELS = math.max(20, CFG.FOV_PIXELS - 10); fovFrame.Size = UDim2.new(0, CFG.FOV_PIXELS*2, 0, CFG.FOV_PIXELS*2); label.Text = "FOV Size: " .. tostring(CFG.FOV_PIXELS); if clickSound then clickSound:Play() end end)
    more.MouseButton1Click:Connect(function() if not settingsFrame.Visible then return end; CFG.FOV_PIXELS = math.min(400, CFG.FOV_PIXELS + 10); fovFrame.Size = UDim2.new(0, CFG.FOV_PIXELS*2, 0, CFG.FOV_PIXELS*2); label.Text = "FOV Size: " .. tostring(CFG.FOV_PIXELS); if clickSound then clickSound:Play() end end)
end

-- Spawn point buttons (compact)
local spawnSetBtn = safeNew("TextButton"); spawnSetBtn.Size = UDim2.new(0.46, -12, 0, 30); spawnSetBtn.Position = UDim2.new(0.02, 8, 0, 164); spawnSetBtn.Text = "Set Spawn"; applyTextStyle(spawnSetBtn, 14, true); safeParent(spawnSetBtn, settingsFrame); makeRound(spawnSetBtn,8); addStroke(spawnSetBtn,1); addGradient(spawnSetBtn, Color3.fromRGB(255,120,120), Color3.fromRGB(200,80,80), 0)
local spawnTPBtn  = safeNew("TextButton"); spawnTPBtn.Size = UDim2.new(0.46, -12, 0, 30); spawnTPBtn.Position = UDim2.new(0.5, 8, 0, 164); spawnTPBtn.Text = "Teleport to Spawn"; applyTextStyle(spawnTPBtn, 14, true); safeParent(spawnTPBtn, settingsFrame); makeRound(spawnTPBtn,8); addStroke(spawnTPBtn,1); addGradient(spawnTPBtn, Color3.fromRGB(120,200,255), Color3.fromRGB(60,140,220), 0)

-- Settings open/close animation
settingsBtn.MouseButton1Click:Connect(function()
    if clickSound then clickSound:Play() end
    if settingsFrame.Visible then
        tween(settingsFrame, {Position = UDim2.new(0.5, -150, 0.2, -40), Size = UDim2.new(0,300,0,180)}, 0.12)
        tween(settingsFrame, {Position = UDim2.new(0.5, -150, 0.5, 0), Size = UDim2.new(0,0,0,0)}, 0.18)
        task.delay(0.18, function() settingsFrame.Visible = false end)
    else
        settingsFrame.Position = UDim2.new(0.5, -150, 0.5, 40)
        settingsFrame.Size = UDim2.new(0,0,0,0)
        settingsFrame.Visible = true
        tween(settingsFrame, {Position = UDim2.new(0.5, -150, 0.25, 0), Size = UDim2.new(0,300,0,180)}, 0.22)
    end
end)

-- Toggle aim via aimbotCircle or key (V)
aimbotCircle.MouseButton1Click:Connect(function()
    aiming = not aiming; targetPart = nil; targetHRP = nil
    if clickSound then clickSound:Play() end
    indicatorDot.BackgroundColor3 = aiming and Color3.fromRGB(20,220,100) or Color3.fromRGB(180,30,30)
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.V then
        aiming = not aiming; targetPart = nil; targetHRP = nil
        if clickSound then clickSound:Play() end
        indicatorDot.BackgroundColor3 = aiming and Color3.fromRGB(20,220,100) or Color3.fromRGB(180,30,30)
    end
end)

-- ======= LOW POLY FPS BOOSTER =======
local LowPolyBooster = {}
LowPolyBooster.enabled = false
LowPolyBooster.cache = {postfx = {}, particles = {}, trails = {}, beams = {}, materials = {}, castshadows = {}, shadows = nil}

function LowPolyBooster:scan()
    self.cache.postfx = {}
    for _, inst in ipairs(Lighting:GetChildren()) do
        if inst:IsA("DepthOfFieldEffect") or inst:IsA("BloomEffect") or inst:IsA("BlurEffect") or inst:IsA("SunRaysEffect") or inst:IsA("ColorCorrectionEffect") then
            table.insert(self.cache.postfx, {obj = inst, enabled = inst.Enabled})
        end
    end
    self.cache.particles = {}
    self.cache.trails = {}
    self.cache.beams = {}
    self.cache.materials = {}
    self.cache.castshadows = {}
    for _, d in ipairs(Workspace:GetDescendants()) do
        if d:IsA("ParticleEmitter") then table.insert(self.cache.particles, {obj=d, rate=d.Rate}) end
        if d:IsA("Trail") then table.insert(self.cache.trails, {obj=d, enabled=d.Enabled}) end
        if d:IsA("Beam") then table.insert(self.cache.beams, {obj=d, enabled=d.Enabled}) end
        if d:IsA("BasePart") then table.insert(self.cache.materials, {obj=d, material=d.Material}); table.insert(self.cache.castshadows, {obj=d, cast=d.CastShadow}) end
    end
    self.cache.shadows = Lighting.GlobalShadows
end

function LowPolyBooster:apply()
    if self.enabled then return end
    self:scan()
    for _, rec in ipairs(self.cache.postfx) do if rec.obj then rec.obj.Enabled = false end end
    for _, rec in ipairs(self.cache.particles) do if rec.obj and rec.obj.Rate then rec.obj.Rate = math.max(0, math.floor(rec.obj.Rate * 0.05)) end end
    for _, rec in ipairs(self.cache.trails) do if rec.obj then rec.obj.Enabled = false end end
    for _, rec in ipairs(self.cache.beams) do if rec.obj then rec.obj.Enabled = false end end
    Lighting.GlobalShadows = false
    for _, rec in ipairs(self.cache.materials) do if rec.obj then pcall(function() rec.obj.Material = Enum.Material.SmoothPlastic; rec.obj.CastShadow = false end) end end
    self.enabled = true
end

function LowPolyBooster:restore()
    if not self.enabled then return end
    for _, rec in ipairs(self.cache.postfx) do if rec.obj then rec.obj.Enabled = rec.enabled end end
    for _, rec in ipairs(self.cache.particles) do if rec.obj then rec.obj.Rate = rec.rate end end
    for _, rec in ipairs(self.cache.trails) do if rec.obj then rec.obj.Enabled = rec.enabled end end
    for _, rec in ipairs(self.cache.beams) do if rec.obj then rec.obj.Enabled = rec.enabled end end
    if self.cache.shadows ~= nil then Lighting.GlobalShadows = self.cache.shadows end
    for _, rec in ipairs(self.cache.materials) do if rec.obj then pcall(function() rec.obj.Material = rec.material end) end end
    for _, rec in ipairs(self.cache.castshadows) do if rec.obj then pcall(function() rec.obj.CastShadow = rec.cast end) end end
    self.enabled = false
end

LowPolyBooster.setEnabled = function(self, v) if v then self:apply() else self:restore() end end
boosterToggle.MouseButton1Click:Connect(function()
    if clickSound then clickSound:Play() end
    LowPolyBooster:setEnabled(not LowPolyBooster.enabled)
    boosterToggle.Text = LowPolyBooster.enabled and "BOOST ON" or "BOOST OFF"
end)

-- ======= TARGETING HELPERS =======
local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Exclude

local function hasLineOfSight(fromPos, toPos, ignore)
    rayParams.FilterDescendantsInstances = ignore or {LocalPlayer.Character, Camera}
    local hit = Workspace:Raycast(fromPos, (toPos - fromPos), rayParams)
    return not hit
end

local function getPingSeconds()
    local ms = 0
    local provider = Stats and Stats.Network and Stats.Network:FindFirstChild("ServerStatsItem")
    if provider and provider:FindFirstChild("Data Ping") then
        local item = provider["Data Ping"]
        local ok, val = pcall(function() return item:GetValue() end)
        if ok and type(val) == "number" then ms = val end
    end
    return math.max(0, ms) / 1000
end

local function computeLeadPosition(part, hrp)
    if not CFG.USE_PREDICTION or not hrp or not part then return part and part.Position or nil end
    local camPos = Camera.CFrame.Position
    local targetPos = part.Position
    local dist = (targetPos - camPos).Magnitude
    local vel = Vector3.zero
    if hrp and hrp:IsA("BasePart") then vel = hrp.Velocity end
    local baseTime = (CFG.BULLET_SPEED > 0) and (dist / CFG.BULLET_SPEED) or 0
    local ping = getPingSeconds()
    local frameDelay = math.clamp(avgDelta, 0, 1)
    local leadTime = math.clamp(baseTime + ping + frameDelay, 0, 0.35)
    local lead = vel * leadTime
    return targetPos + lead
end

local function inFOVScreen(pos)
    local scr, onScreen = Camera:WorldToViewportPoint(pos)
    if not onScreen then return false end
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    local d = (Vector2.new(scr.X, scr.Y) - center).Magnitude
    return d <= CFG.FOV_PIXELS
end

local function isRealPlayer(plr)
    if not plr or plr == LocalPlayer then return false end
    if CFG.USE_FRIEND_FILTER and pcall(function() return LocalPlayer:IsFriendsWith(plr.UserId) end) then return false end
    local ch = plr.Character
    if not ch then return false end
    local hum = ch:FindFirstChildWhichIsA("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    return true
end

local function pickBest(ignoreFOV)
    local bestPart, bestHRP, bestScore = nil, nil, math.huge
    local camCF = Camera.CFrame; local camPos = camCF.Position; local camLook = camCF.LookVector
    for _, plr in ipairs(Players:GetPlayers()) do
        if isRealPlayer(plr) then
            local ch = plr.Character
            local prt = ch and (ch:FindFirstChild(CFG.LOCK_PART) or ch:FindFirstChild("HumanoidRootPart"))
            local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
            if prt and hrp then
                local worldDist = (prt.Position - camPos).Magnitude
                if worldDist <= CFG.AIM_RADIUS then
                    local predicted = computeLeadPosition(prt, hrp) or prt.Position
                    if (not CFG.REQUIRE_VISIBLE) or hasLineOfSight(camPos, predicted, {LocalPlayer.Character, Camera}) then
                        local score
                        if CFG.TARGET_PRIORITY == "Angle" then
                            local dirUnit = (predicted - camPos).Unit
                            local dot = camLook:Dot(dirUnit)
                            score = -dot + worldDist/10000
                        elseif CFG.TARGET_PRIORITY == "Distance" then
                            score = worldDist
                        else
                            local scr, onScreen = Camera:WorldToViewportPoint(predicted)
                            if (not onScreen or (not ignoreFOV and not inFOVScreen(predicted))) then score = 1e9 else local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2); local d = (Vector2.new(scr.X,scr.Y) - center).Magnitude; score = d + worldDist/1000 end
                        end
                        if score < bestScore then bestScore, bestPart, bestHRP = score, prt, hrp end
                    end
                end
            end
        end
    end
    targetPart = bestPart; targetHRP = bestHRP; return targetPart
end

local function aimAt(pos)
    local origin = Camera.CFrame.Position
    if CFG.USE_CAM_HEIGHT then origin = origin + Vector3.new(0, CFG.CAM_HEIGHT, 0) end
    local desired = CFrame.new(origin, pos) * CFrame.Angles(math.rad(CFG.SCREEN_TILT), 0, 0)
    if CFG.AIM_MODE == "Snap" or CFG.SMOOTHING <= 0 then
        pcall(function() Camera.CFrame = desired end)
    else
        local cur = Camera.CFrame; local alpha = math.clamp(CFG.SMOOTHING, 0, 1); local nextCF = cur:Lerp(desired, alpha)
        pcall(function() Camera.CFrame = nextCF end)
    end
end

-- ======= RENDER LOOP =======
RunService.RenderStepped:Connect(function(dt)
    avgDelta = CFG.FPS_SMOOTH_FACTOR * avgDelta + (1 - CFG.FPS_SMOOTH_FACTOR) * dt
    if CFG.SHOW_FPS_COUNTER and fpsLabel then local fps = (avgDelta>0) and (1/avgDelta) or 0; fpsLabel.Text = string.format("FPS: %.1f", fps); fpsLabel.Visible = true else fpsLabel.Visible = false end
    if fovFrame then fovFrame.Size = UDim2.new(0, CFG.FOV_PIXELS*2, 0, CFG.FOV_PIXELS*2) end
    local look = Camera.CFrame.LookVector; local yaw = math.atan2(look.X, look.Z); local pitch = math.asin(-look.Y); local now = tick()
    if lastYaw ~= nil then local dy = math.abs(yaw - lastYaw); if dy > math.pi then dy = math.abs(dy - 2*math.pi) end; local dp = math.abs(pitch - lastPitch); if (dy >= 0.006 or dp >= 0.02) and (now - lastSwitchTick) >= 0.08 then pickBest(true); lastSwitchTick = now end end
    lastYaw = yaw; lastPitch = pitch
    if aiming then
        local keep = false
        if targetPart and targetHRP then
            local camPos = Camera.CFrame.Position
            local within = (targetPart.Position - camPos).Magnitude <= CFG.AIM_RADIUS
            if within then
                if not CFG.REQUIRE_VISIBLE then keep = true else local predicted = computeLeadPosition(targetPart, targetHRP) or targetPart.Position; local seen = hasLineOfSight(camPos, predicted, {LocalPlayer.Character, Camera}); if seen then keep = true; lastSeenVisibleAt = now else keep = (now - lastSeenVisibleAt) <= CFG.VIS_STICKY_TIME end end
            end
        end
        if not keep then pickBest(false) end
        if targetPart and targetHRP then local aimPos = computeLeadPosition(targetPart, targetHRP) or targetPart.Position; aimAt(aimPos) end
    end
end)

-- ======= SPAWN POINT SYSTEM =======
local function placeSpawnMarker(cframe)
    if spawnMarker and spawnMarker.Parent then spawnMarker:Destroy(); spawnMarker = nil end
    local mark = Instance.new("Part")
    mark.Name = "MerebennieSpawnMarker"
    mark.Size = CFG.SPAWN_MARKER_SIZE
    mark.Anchored = true
    mark.CanCollide = false
    mark.Material = Enum.Material.Neon
    mark.Color = Color3.fromRGB(220,40,40)
    mark.CFrame = cframe * CFrame.new(0, CFG.SPAWN_MARKER_SIZE.Y/2, 0)
    safeParent(mark, Workspace)
    spawnMarker = mark
end

local function setSpawnPointAtPlayer()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
    if not hrp then return end
    local rayParams = RaycastParams.new(); rayParams.FilterDescendantsInstances = {char}; rayParams.FilterType = Enum.RaycastFilterType.Exclude
    local down = Workspace:Raycast(hrp.Position, Vector3.new(0, -200, 0), rayParams)
    local groundCFrame = CFrame.new(hrp.Position)
    if down and down.Position then groundCFrame = CFrame.new(Vector3.new(hrp.Position.X, down.Position.Y, hrp.Position.Z)) end
    spawnPointCFrame = groundCFrame
    placeSpawnMarker(groundCFrame)
end

local function teleportToSpawnPoint()
    if not spawnPointCFrame then return end
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
    if not hrp then return end
    hrp.CFrame = spawnPointCFrame + Vector3.new(0, 3, 0)
end

spawnSetBtn.MouseButton1Click:Connect(function()
    if clickSound then clickSound:Play() end
    setSpawnPointAtPlayer()
end)
spawnTPBtn.MouseButton1Click:Connect(function()
    if clickSound then clickSound:Play() end
    teleportToSpawnPoint()
end)

-- ======= AUTO ENABLE BOOSTER =======
LowPolyBooster:setEnabled(CFG.BOOSTER_DEFAULT)

-- ======= READY =======
print("[DeltaAim] Merebennie Final Build loaded and UI fixed for Delta Mobile.")
